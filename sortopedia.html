<!-- copyright information:
FILE: Sortopedia.html
AUTHOR: Dayan Petrov
UNIVERSITY: The University of Sheffield
WEB: dissertation.dayanpetrow.eu
DESCRIPTION: Information about Sorting Algorithms
LAST UPDATED: 28-04-2017
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Visualisation of Sorting Algorithms</title>

    <!-- Bootstrap -->
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Custom css -->
    <link href="css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body> <! -- body begins -->

<!-- Navbar -->
<nav class="navbar navbar-default navbar-fixed-top"> <!-- navbar-fixed-top -->
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>                        
      </button>
      <a class="navbar-brand" href="http://sheffield.ac.uk">THE UNIVERSITY OF SHEFFIELD</a>
    </div>
    <div class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="index.html">HOME</a></li>
        <li><a href="database.html">VISUALISE</a></li>
        <li><a href="compare.html">COMPARE</a></li>
        <li><a href="sortopedia.html">SORTOPEDIA</a></li>
      </ul>
    </div>
  </div>
</nav>

<!-- SORTOPEDIA -->
<div class="container-fluid intro text-center">
 <div class="container">
	
	<div class="row">
		
		<div class="col-xs-12 col-sm-4 col-md-3">
		
			<div class="sortopedia-panel">
				<ul class="list-unstyled">
				  <li>
					<a data-toggle="pill" href="#introduction">
						<button>Introduction</button>
					</a>
				  </li>
				  <li>
					<a data-toggle="pill" href="#complexity">
						<button>Time complexity</button>
					</a>
				  </li>
				  <li>
					<a data-toggle="pill" href="#bubblesort">
						<button>BubbleSort</button>
					</a>
				  </li>
				  <li>
					<a data-toggle="pill" href="#selectionsort">
						<button>SelectionSort</button>
					</a>
				  </li>
				  <li>
					<a data-toggle="pill" href="#insertionsort">
						<button>InsertionSort</button>
					</a>
				  </li>
				  <li>
					<a data-toggle="pill" href="#radixsort">
						<button>RadixSort</button>
					</a>
				  </li>
				  <li>
					<a data-toggle="pill" href="#mergesort">
						<button>MergeSort</button>
					</a>
				  </li>
				  <li>
					<a data-toggle="pill" href="#heapsort">
						<button>HeapSort</button>
					</a>
				  </li>
				  <li>
					<a data-toggle="pill" href="#quicksort">
						<button>QuickSort</button>
					</a>
				  </li>
				  <li>
					<a data-toggle="pill" href="#countingsort">
						<button>CountingSort</button>
					</a>
				  </li>
				</ul>
			</div> <!-- panel -->
		
		</div> <!-- col-xs-12 col-sm-3 -->
	
			
	
	
	
	
	
	
		<div class="col-xs-12 col-sm-8 col-md-9">
			<div class="sortopedia-panel">
				<div class="tab-content">
				
					<!-- tab -->
					<div id="introduction" class="tab-pane fade in active">
						<h4>Introduction to Sorting Algorithms</h4>
						<p>"Informally, an algorithm is any well-defined computational procedure that takes
							some value, or set of values, as input and produces some value, or set of values, as
							output. An algorithm is thus a sequence of computational steps that transform the
							input into the output."</p>
						<p>A sorting algorithm is an algorithm that takes a sequence of unordered elements as an input and returns the same elements as an output but in 
						specified by certain criterion order. Example ordering can be numerical, decreasing or non-decreasing, or alphabetical.</p>
						<p>
						Many sorting algorithms exist and they are all designed to solve the same problem. However, they can differ vastly in terms of efficiency. 
						Insertion sort takes roughly <b>O(n<sup>2</sup>)</b> time to sort a sequence of <i><b>n</b></i> numbers while merge sort requires <b>O(logn)</b> time for the same input. 
						Even though insertion sort outperforms merge sort for very small-sized arrays, for large <i><b>n</b></i> merge sort is immensely more efficient. 
						The algorithms covered in this project are <b>InsertionSort, SelectionSort, BubbleSort, RadixSort, HeapSort, MergeSort, CountingSort and QuickSort.</b></p>
						<h4>Stability</h4>
						<p>Stability preserves the order of equal elements. In other words, if two elements are equal in the input data, they will appear in the same relative order in the output. 
						Note the positions of the <b>7s</b> in the following example:</p>
						<img src="images/stability/stability.jpg" class="img-responsive" alt="Responsive image"></img>
						<h4>In-place sorting</h4>
						<p>In-place algorithm is an algorithm that uses no extra auxiliary data structure: it does not require any additional storage to manipulate the input. However, use of auxiliary variables may be allowed. In-place sorting algorithm overwrites the input by the output in the process and therefore such algorithm is only based on replacements or swaps.</p>
						<p><b>References: Introduction to Algorithms, 3rd Edition (MIT Press)</b></p>
						<a href="compare.html">
							<button class="panel_button">Compare sorting algorithms</button>
						</a>
					</div>
				
					<!-- tab -->
					<div id="complexity" class="tab-pane fade">
						<h4>Function growth</h4>
						<p>In computer science, Big O notation is used to describe how the processing time changes as the problem size grows. The time complexity of a sorting algorithm is
						expressed using Big O notation. Time complexity means the count of elementary operations performed by the algorithm for some input. We focus on worst-case, 
						average-case and best-case time complexity. For example, <b>O(n<sup>2</sup>)</b> is the upper bound of a function: the algorithm takes at most <b>O(n<sup>2</sup>)</b> 
						time to sort an input (but it may also take less). <b>&Omega;(nlogn)</b> is the lower bound of a function: the algorithm can solve the problem in at least <b>&Omega;(nlogn)</b> 
						time for the best possible scenario. When <b>&Theta;(n<sup>2</sup>)</b> is used to describe worst-case input, it means that the algorithm takes exactly 
						<b>&Theta;(n<sup>2</sup>)</b> to sort the array: that may be an inverse sorted array.</p>
						
						<h4>Complexity chart</h4>
						<img src="images/growth/growth.jpg" class="img-responsive" alt="Responsive image"></img>
						
						<h4>Running time table</h4>
						<div class="table-responsive">
						  <table class="table table-bordered">
							<tr>
							  <th class="active">Algorithm</th>
							  <th class="active">Best</th>
							  <th class="active">Average</th>
							  <th class="active">Worst</th>
							</tr>
							<tr>
							  <td class="active">BubbleSort</td>
							  <td class="warning">&Omega;(n)</td>
							  <td class="danger">&Theta;(n<sup>2</sup>)</td>
							  <td class="danger">O(n<sup>2</sup>)</td>
							</tr>
							<tr>
							  <td class="active">SelectionSort</td>
							  <td class="danger">&Omega;(n<sup>2</sup>)</td>
							  <td class="danger">&Theta;(n<sup>2</sup>)</td>
							  <td class="danger">O(n<sup>2</sup>)</td>
							</tr>
							<tr>
							  <td class="active">InsertionSort</td>
							  <td class="warning">&Omega;(n)</td>
							  <td class="danger">&Theta;(n<sup>2</sup>)</td>
							  <td class="danger">O(n<sup>2</sup>)</td>
							</tr>
							<tr>
							  <td class="active">RadixSort</td>
							  <td class="success">&Omega;(nk)</td>
							  <td class="success">&Theta;(nk)</td>
							  <td class="success">O(nk)</td>
							</tr>
							<tr>
							  <td class="active">MergeSort</td>
							  <td class="info">&Omega;(nlogn)</td>
							  <td class="info">&Theta;(nlogn)</td>
							  <td class="info">O(nlogn)</td>
							</tr>
							<tr>
							  <td class="active">HeapSort</td>
							  <td class="info">&Omega;(nlogn)</td>
							  <td class="info">&Theta;(nlogn)</td>
							  <td class="info">O(nlogn)</td>
							</tr>
							<tr>
							  <td class="active">QuickSort</td>
							  <td class="info">&Omega;(nlogn)</td>
							  <td class="info">&Theta;(nlogn)</td>
							  <td class="danger">O(n<sup>2</sup>)</td>
							</tr>
							<tr>
							  <td class="active">CountingSort</td>
							  <td class="success">&Omega;(n+k)</td>
							  <td class="success">&Theta;(n+k)</td>
							  <td class="success">O(n+k)</td>
							</tr>
						  </table>
						</div>
						
					</div>
					
					<!-- tab -->
					<div id="bubblesort" class="tab-pane fade">
						<h4>BubbleSort</h4>
						<p>Bubble sort is a simple sorting algorithm with worst and average time complexity of <b>&Theta;(n<sup>2</sup>)</b>  making it inefficient for large arrays. Bubble sort is a stable sorting algorithm.</p>
					
						<h4>Working principle</h4>
						<p>The idea is simple. Scan the whole array in pairs of adjacent elements and swap the elements that are in wrong order.  Bubble sort can detect already sorted arrays 
						and thus has <b>O(n)</b> best case run-time. Interesting thing about bubble sort is that elements moving in different directions have different speed. For example. 
						assume the largest element in the array is positioned in the beginning. That element will win all comparisons to the end of the array and will take its sorted
						position in one loop iteration. On the contrary, the smallest element being in the end will move just one place to the left per loop iteration.</p>
						
						<h4>Pseudo code and demo</h4>
						<img src="images/bubble_sort/bubble_sort.png" class="img-responsive" alt="Responsive image"></img>
						<pre><code><p class="pcode">BubbleSort pseudo code with ability to detect a sorted array
for i = 0 to A.length - 1
    swapped = false
    for j = 0 to A.length - 1
        if A[j] > A[j+1]
        swap A[j] with A[j+1]
        swapped = true
    end for
    if swapped is false then
        break
    end if
end for</p></code></pre>
						<pre><code><p class="pcode">Standard implementation of BubbleSort
for i = 0 to A.length - 1
    for j = 0 to A.length - 1
        if A[j] > A[j+1]
        swap A[j] with A[j+1]
    end for
end for</p></code></pre>
						
						<p><b>References: <a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank">BubbleSort on Wikipedia</a></b></p>
						<a href="animations/bubble_sort.html">
							<button class="panel_button">Visualisation of BubbleSort</button>
						</a>
						<a href="compare.html">
							<button class="panel_button">Test performance</button>
						</a>
					</div>
					
					<!-- tab -->
					<div id="selectionsort" class="tab-pane fade">
						<h4>SelectionSort</h4>
						<p>Selection sort is an in-place sorting algorithm with <b>O(n<sup>2</sup>)</b> time complexity for any input case. The algorithm is inefficient for large 
						inputs and generally falls behind insertion sort. However, selection sort is based on a simple idea - scan to whole array to find the smallest or the 
						largest element. The algorithm is easy to understand and analyse. Selection sort preserves the order of equal elements.</p>
						
						<h4>Working principle</h4>
						<p>The input array is divided into two parts - sorted sub-list and sub-list of the remaining items. The sorted sequence builds up from left to right. 
						On each iteration the algorithm finds the smallest or the largest element in the sub-list of remaining items and puts it at rightmost position in the sorted sub-list. </p>
						
						<h4>Pseudocode and demo</h4>
						<img src="images/selection_sort/selection-sort-demo.jpg" class="img-responsive" alt="Responsive image"></img>
						<pre><code><p class="pcode">for  i = 0 to A.length - 1
    for j = i + 1 to A.length
        if A[i] > A[j]
            swap A[i] and A[j]
        end if
    end for
end for</p></code></pre>

						<p><b>References: <a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank">SelectionSort on Wikipedia</a></b></p>
						<a href="animations/selection_sort.html">
							<button class="panel_button">Visualisation of SelectionSort</button>
						</a>
						<a href="compare.html">
							<button class="panel_button">Test performance</button>
						</a>
					</div>
					
					<!-- tab -->
					<div id="insertionsort" class="tab-pane fade">
						<h4>InsertionSort</h4>
						<p>Insertion sort is a simple sorting algorithm that builds the sorted array one item at a time. Despite being less efficient than most of the modern algorithms, 
						insertion sort have its advantages. The working principle is easy to implement and is efficient for small-sized arrays. The run-time of the algorithm can drop 
						dramatically for nearly sorted arrays yielding a time complexity of <b>O(nk)</b> when each element of the input is no more than <i><b>k</b></i> places away from its sorted position.
						Insertion sort preserves the relative order of equal elements and thus is considered stable. The best case input is an already sorted array as every element is 
						compared just once to the rightmost element in the sorted sequence. This results in linear running time of <b>O(n)</b>. The worst case is a sorted array in 
						reverse order. Each iteration moves the first element in the unsorted data to the first position of the sorted sequence by comparing it to all sorted 
						elements and moving all of them one position on the right. This case results in quadratic worst case running time of <b>&Theta;(n<sup>2</sup>)</b>. The average case
						is also quadratic and thus making insertion sort impractical for large arrays. However, the algorithm is still one of the fastest for sorting 
						small-sized arrays. Insertion sort is very similar to selection sort which is discussed in the next section. Some implementations of divide-and-conquer 
						algorithms such as quick sort and merge sort use insertion sort for sorting sub-arrays that are smaller than a given threshold. </p>
						<h4>Working principle</h4>
						<p>The way most of the people sort cards in bridge hand is similar to the working principle of insertion sort. The algorithm iterates, taking one element from the 
						input on each repetition, and builds a sorted output list. Insertion sort removes one element from the input and inserts it to its correct position in the sorted list. 
						It repeats until there are no elements left in the input data.</p>
						<img src="images/insertion_sort/working-principle-1.png" class="img-responsive" alt="Responsive image"></img>
						<img src="images/insertion_sort/working-principle-2.png" class="img-responsive" alt="Responsive image"></img>
						
						<h4>Pseudocode and demo</h4>
						<pre><code><p class="pcode">for  j = 2 to A.length
        key = A[j]
        #insert A[j] into the sorted sequence A[1..j-1]
        i = j - 1
        while i > 0 and A[i] > key
            A[i+1] = A[i]
            i = i - 1
        end while
        A[i+1] = key
end for</p></code></pre>
						<img src="images/insertion_sort/demo.png" class="img-responsive" alt="Responsive image"></img>
						<p>Demo of the working principle of Insertion sort. The darker gray background shows the sorted sequence. The number that is written in the sorted sequence is marked with a slightly thicker border. The number that is read is underlined and coloured in black.</p>
						<p><b>References: <a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank">InsertionSort on Wikipedia</a></b></p>
						<a href="animations/insertion_sort.html">
							<button class="panel_button">Visualisation of InsertionSort</button>
						</a>
						<a href="compare.html">
							<button class="panel_button">Test performance</button>
						</a>
					</div>
					
					<!-- tab -->
					<div id="radixsort" class="tab-pane fade">
						<h4>RadixSort</h4>
						<p>Radix sort is a non-comparative sorting algorithm that build a sorted array by grouping keys that share the same significant position and value. 
						For example, initially <b>104</b> and <b>74</b> are both grouped as ending with the digit <b>4</b>. Secondly, <b>104</b> is grouped with elements that have <b>0</b> as a 
						second least significant digit and <b>74</b> is grouped with numbers sharing the <b>7</b>. Radix sort can be used to sort strings of characters. It is an 
						alternative to high-performance comparison sorts that require <b>O(nlogn)</b> comparisons.</p>
						
						<h4>Working princple</h4>
						<p>Least significant digit radix sort is fast and stable sorting algorithm with time complexity of <b>O(wn)</b> for <i>n</i> keys with <i>w</i> average key length.
						This time complexity is possible when keys of different length are put into groups according to their length and radix sort is ran on each group. 
						The different results are then combined. The working principle is the following: take the last digit of the keys, group the keys based on that one digit,
						take the next digit (10s,100s...), group keys based on that digit and repeat the grouping process until no digits remain.</p>
						
						<h4>Pseudocode and demo</h4>
						<img src="images/radix_sort/radixsort-demo.jpg" class="img-responsive" alt="Responsive image"></img>
						
						<pre><code><p class="pcode">Radix-Sort(A,d) where d is the length of the elements
for i = 1 to d
    use a stable sort to sort array A on digit i</p></code></pre>
						<p>Note: The visualisation of RadixSort in this project uses BucketSort</p>
						
						<p><b>References: <a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank">RadixSort on Wikipedia</a></b></p>
						<a href="animations/radix_sort.html">
							<button class="panel_button">Visualisation of RadixSort</button>
						</a>
						<a href="compare.html">
							<button class="panel_button">Test performance</button>
						</a>
					</div>
					
					<!-- tab -->
					<div id="mergesort" class="tab-pane fade">
						<h4>MergeSort</h4>
						<p>Merge sort is a divide-and-conquer algorithm: the problem is divided into sub-problems which are solved separately and a general solution is produced 
						by combining the sub-solutions. It is efficient, comparison-based and stable sorting algorithm. The time complexity of merge sort is <b>O(nlogn)</b> in all 
						possible input cases.</p>
						
						<h4>Working principle</h4>
						<p>The input array is divided into <i>n</i> sub-lists. Put in other words, each number is considered a sub-list. 
						Then repeatedly merge sub-lists in twos, fours, eights, etc. until the sorted sequence is produced.</p>
						
						<h4>Demo of Bottom-Up MergeSort</h4>
						<img src="images/merge_sort/mergesort.jpg" class="img-responsive" alt="Responsive image"></img>
						<p>Note: The MergeSort animation in this project implements a version of MergeSort called Bottom-Up MergeSort</p>
						
						<p><b>References: <a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank">MergeSort on Wikipedia and implementations</a></b></p>
						<a href="animations/merge_sort.html">
							<button class="panel_button">Visualisation of MergeSort</button>
						</a>
						<a href="compare.html">
							<button class="panel_button">Test performance</button>
						</a>
					</div>
					
					<!-- tab -->
					<div id="heapsort" class="tab-pane fade">
						<h4>HeapSort</h4>
						<p>Heap sort combines to best attributes of merge sort and insertion sort: in-place sorting from insertion sort and the run-time <b>O(nlogn)</b> of merge sort.
						It introduces the heap data structure: a nearly complete binary tree where each node is an element of the array. Two kinds of heaps exist: min-heaps
						and max-heaps and they both satisfy the heap property. The max-heap property states that a value of a node is at most the value of its parent. This means
						that the biggest number is always the root.</p>
						
						<h4>Working principle</h4>
						<p>Procedure called <b>Max-Heapify</b> is used to maintain the max-heap property. We use the <b>Build-Max-Heap</b> procedure to run <b>Max-Heapify</b> on every node in the tree.</p>
					
						<h4>Demo</h4>
						<img src="images/heap_sort/heapsort-demo.jpg" class="img-responsive" alt="Responsive image"></img>
						
						<p><b>References: <a href="https://en.wikipedia.org/wiki/Heap_sort" target="_blank">HeapSort on Wikipedia and implementations</a> <br />
						Introduction to Algorithms, 3rd Edition (MIT Press)</b></p>
						<a href="animations/heap_sort.html">
							<button class="panel_button">Visualisation of HeapSort</button>
						</a>
						<a href="compare.html">
							<button class="panel_button">Test performance</button>
						</a>
					</div>
					
					<!-- tab -->
					<div id="quicksort" class="tab-pane fade">
						<h4>QuickSort</h4>
						<p>Quick sort is an efficient comparison sort. Most implementations of quick sort are not stable but the algorithm can operate 
						in-place and thus requires small amount of memory. The average performance of quick sort is <b>O(nlogn)</b> but some implementations 
						are faster than merge sort and heap sort.</p>
						
						<h4>Working principle</h4>
						<p>Firstly, a pivot element is chosen: many strategies exist to choose the pivot but the implementation in the project is randomised quick sort 
						and thus the pivot is randomly picked. The next step is partitioning: put all elements that are smaller than the pivot before it and all 
						bigger elements after it (where equal elements go is a matter of choice). After the partitioning the pivot is at its correct position in 
						the output. The rest of the array is divided into two partitions. Then the same procedures start again recursively on each partition and 
						then on each new partition until the array is sorted. </p>
						
						<h4>Demo</h4>
						<img src="images/quick_sort/quicksort-demo.jpg" class="img-responsive" alt="Responsive image"></img>
						
						<p><b>References: <a href="https://en.wikipedia.org/wiki/Quick_sort" target="_blank">QuickSort on Wikipedia and implementations</a> <br />
						Introduction to Algorithms, 3rd Edition (MIT Press)</b></p>
						<a href="animations/rquick_sort.html">
							<button class="panel_button">Visualisation of Randomised-QuickSort</button>
						</a>
						<a href="animations/quick_sort.html">
							<button class="panel_button">Visualisation of QuickSort</button>
						</a>
						<a href="compare.html">
							<button class="panel_button">Test performance</button>
						</a>
					</div>
       
					<!-- tab -->
					<div id="countingsort" class="tab-pane fade">
						<h4>CountingSort</h4>
						<p>CountingSort is extremely fast but not-in-place sorting algorithm and thus requires a lot of aditional memory to perform. The running time of the algorithm is <b>O(n+k)</b>.</p>
						<h4>Working principle</h4>
						<p>Initially, a counting array is build. The length of this array is equal to the biggest element from the array that will be sorted. The next step is to increment <b>count[i]</b> 
						for each occurrence of element <b>i</b>. For example, reading element <b>21</b> in the original array increments the value of <b>count[21] by 1</b>. 
						Lastly, rewrite the original array by using the information stored in the counting array. Look at the example below and the visualisation of the algorithm for more information.</p>
						<h4>Demo</h4>
						<img src="images/counting_sort/countingsort-demo.jpg" class="img-responsive" alt="Responsive image"></img>
						
						<a href="animations/counting_sort.html">
							<button class="panel_button">Visualisation of CountingSort</button>
						</a>
						<a href="compare.html">
							<button class="panel_button">Test performance</button>
						</a>
					</div>
				</div>
			</div> <!-- panel -->
		
		</div> <!-- col-xs-12 col-sm-9 -->
	
	
	
	
	
	
	
	
	</div> <!-- row -->
 </div>
</div>

<!-- Footer -->
<footer class="container-fluid text-center">
  <p class="copyright">The project is developed by <a href="http://dayanpetrow.eu">Dayan Petrov</a> for <a href="http://sheffield.ac.uk">The University of Sheffield</a></p> 
  <p class="copyright">All rights reserved &copy; 2017</p>
</footer>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="bootstrap/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap/js/bootstrap.min.js"></script>
  </body> <!-- body ends -->
</html>